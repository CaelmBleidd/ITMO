<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C++</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#c">C++</a>
<ul>
<li></li>
<li></li>
<li><a href="#perfect-forwarding">Perfect-forwarding</a></li>
<li><a href="#новая-пара-новая-жизнь">Новая пара, новая жизнь</a></li>
<li><a href="#stdfunction">std::function</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#bind-и-variadic-templates">Bind и variadic-templates</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="c">C++</h1>
<h2 id="section"></h2>
<p>Пусть у нас есть <em>большая</em> структура.</p>
<pre><code>struct big_struct {
	std::array&lt;int, 10&gt; data; 
};
</code></pre>
<p>При вызове функции <code>void foo(int)</code> передаётся копированием через регистры (У MS до четырёх, GCC до шести). Следующие аргументы будут передаваться на стек. С указателем <code>int *</code> то же самое.  Ссылки <code>int&amp;</code> будут передаваться как указатели.<br>
При вызове <code>void foo (big_struct)</code></p>
<p>Пусть есть код:</p>
<pre><code>big_struct a; 
f(a); 
</code></pre>
<p>Есть два варианта:</p>
<pre><code>1.  
{
	big_struct copy = a;
	f(copy); 
}
void f(big_struct&amp;) { ... }

2. Использует компиляторы паскаля, например. 
f(a); 
void f(big_struct const&amp; a) {
	big_struct copy = a;
	...
}
</code></pre>
<p>Используют <em>все</em> компиляторы плюсов. Потому что копию в таком случае можно не делать, если a больше нигде не использоваться при вызове (например, rvalue).</p>
<p><em>Маленькие</em> структуры всё равно передаются в регистры (по значению).</p>
<h3 id="возвращение-значений">Возвращение значений</h3>
<p><code>int foo()</code> возвращает значение в регистр. То же самое с указателями и ссылками. Если возвращаем <em>маленькую</em> структуру, то она тоже вернётся в регистры. В функции <code>big_struct foo()</code>  используется место в стеке. Вызов работает следующим образом: вызывающая сторона резервирует достаточное место для возвращения big_struct.</p>
<pre><code>big_struct f(); 
void g() {
	big_struct a = f(); 
} 
</code></pre>
<p>Как это транслируется:</p>
<pre><code>void f(void * result) // void*, потому что на момент вызова функции конструктор ещё не вызван 
{
	...
	ctor_big_struct(result); 
}

void g() {
	char a_buf[sizeof(big_struct)];
	f(a_buf);
	big_struct&amp; a = (big_struct&amp;)a_buf; 
}
</code></pre>
<p>Посмотрим на такой код, сколько здесь копирований?</p>
<pre><code>big_struct g(); 
void f(big_struct); 
f(g());
</code></pre>
<p>Здесь нет <em>ни одного</em> копирования.</p>
<pre><code>void h() {
	f(g());
}
</code></pre>
<p>Как работает h (результат вызова функции g – rvalue):</p>
<pre><code>void f(big_struct); 
void g(void*); 
void h() {
	char tmp_buf[sizeof(big_struct)];
	g(tmp_buf); 
	big_struct&amp; tmp = (big_struct&amp;)tmp_buf; 
	f(tmp);
}
</code></pre>
<p>Ещё два места, где копирование <strong>не</strong> делается<br>
Пусть у нас есть функция <code>g()</code>.</p>
<pre><code>struct big_struct {
	big_struct(int, int, int); 
};

big_struct g() {
	...
	return big_struct(1, 2, 3);
}
</code></pre>
<p>Наивный вариант:</p>
<pre><code>void g(void *result) {
	char tmp[sizeof(big_struct)];
	big_struct_ctor(tmp, 1, 2, 3); 
	big_struct_ctor(result, (big_struct&amp;) tmp); 
</code></pre>
<p>В реальности:</p>
<pre><code>void g(void *result) {
	big_struct_ctor(result, 1, 2, 3); 
}
</code></pre>
<p>В примере выше, даже если конструктор копирования имеет side-эффекты, он не будет вызван.<br>
В простонародии такое преобразование называется <strong>Return Value Optimization (RVO)</strong>.</p>
<p>Рассмотрим другой пример:</p>
<pre><code>big_struct g() {
	big_struct tmp(1, 2, 3); 
	...
	tmp.f(); 
	return tmp;
}
</code></pre>
<p>В таком случае тоже можно не делать копирования, для этого необходимо создать tmp на месте result.  А вот если на месте … будет <code>if (...) return big_struct(4, 5, 6)</code>, подобное преобразование будет уже недопустимо.<br>
Вот что это преобразуется:</p>
<pre><code>void g(void *result) {
	big_struct_ctor (result, 1, 2, 3); 
	...	
	(big_struct*)result -&gt; f(); 
}
</code></pre>
<p>Последний пример кода не безопасен с точки зрения исключений, т.к. мы ожидаем, что при ошибке в <code>f()</code> не будет ничего записано в result, а в примере что-то будет. Поэтому на практике используют примерно:</p>
<pre><code>try {
	(big_struct*)result -&gt; f(); 
} catch (...) {
	(big_struct*)result -&gt; ~big_struct(); 
	throw;
}
</code></pre>
<p>Это иногда называют <strong>NRVO</strong>. Её нельзя применять, если на момент создания tmp мы не знаем, будет ли он возвращён или нет.</p>
<h2 id="section-1"></h2>
<p>Копируем что-то большое и много:</p>
<pre><code>std::vector&lt;std::string&gt; v; 
std::string s; 
v.push_back(s); 
</code></pre>
<p>Некопируемые объекты:</p>
<pre><code>std::vector&lt;file_descriptor&gt; v; // В С++03 вектор с таким не будет работать
</code></pre>
<p>Как пофиксить в С++03:<br>
<code>std::vector&lt;file_descriptor*&gt;</code> – более-менее очевидное (не круто)<br>
<code>std::vector&lt;boost::shared_ptr&lt;file_descriptor&gt;&gt; v;</code> – для прошаренных  (ещё менее круто)<br>
А когда копировали что-то большое и много, не делали ничего,  копируется и копируется.</p>
<h3 id="move-семантика">Move-семантика</h3>
<p>Что такое move? Допустим, у нас есть конструктор копирования <code>string (string const&amp;)</code>. Он берёт аргумент и создаёт точно такую же строчку, как передали. Однако, часто нам уже не нужно старое значение, старый объект. Идея такая: хочу создать новую строчку, которая такая же, как исходная, а исходную можешь испортить, это не имеет значения. Для большинства стандартных контейнеров он просто перебросит указатели, а в исходном занулит. Очень хорошая операция, не бросает исключения.<br>
Плюс в том, что многие объекты, которые не умеют копироваться, легко научить муваться. Например, непонятно, что значит скопировать файловый дескриптор, но понятно, как сделать его невалидную версию и переместить валидную.</p>
<p><strong>NB</strong>: если посортить вектор <code>auto_ptr</code>, многие (или все) элементы занулятся из-за строчки <code>T pivot = arr[i]</code>.</p>
<p>Пусть есть функция  <code>push_back(...)</code>. Хочу понять. когда я могу испортить аргумент, который мне передали, а когда я обязан его не менять. В С++11 появилась возможность перегружать функции по lvalue и rvalue.<br>
Обычные ссылки <code>&amp;</code> теперь называются lvalue-ссылки. Появились ссылки <code>&amp;&amp;</code>, которые называются rvalue-ссылки.</p>
<pre><code>int f();
int a = 5; 
int &amp;b = a; // OK
int &amp;&amp;c = a; // error
int &amp;d = f();  // error
int &amp;&amp;e = f(); // OK
</code></pre>
<p>Как работает <code>push_back</code> с двумя перегрузками:</p>
<pre><code>push_back(T const&amp;); 
push_back(T &amp;&amp;); 
</code></pre>
<p>Если объект lvalue или const, выберется первая перегрузка, иначе – вторая.<br>
Если хотите, чтобы объект умел и копироваться, и муваться – пишите два конструктора, например:</p>
<pre><code>string (string const&amp;); 
string (string &amp;&amp;); 
</code></pre>
<p>Оператор присваивания тоже нужно написать  дважды: копирующий и перемещающий.</p>
<pre><code>void push_back (T const&amp; a) {
	...
	a;
	...
	a;
} // a -- lvalue

void push_back(T &amp;&amp; a) {
	...
	a; 
	...
	a;
} // здесь а тоже lvalue. 
</code></pre>
<p>Т.е. следующий код не сработает:</p>
<pre><code>void foo(T &amp;&amp;); 
void push_back(T &amp;&amp; a) {
	foo(a); // error, т.к. a -- lvalue
}
</code></pre>
<p>Можно пофиксить таким образом: <code>foo(static_cast&lt;T &amp;&amp;&gt;(a))</code>.  Таких операций бывает много, поэтому существует специальная функция:</p>
<pre><code>template &lt;typename T&gt; 
T &amp;&amp; move (T &amp;obj) {
	return static_cast&lt;T &amp;&amp;&gt;(obj)l 
}
</code></pre>
<p>Как делать <strong>не</strong> нужно, типичная ошибка:</p>
<pre><code>string foo() {
	string res = "hello"; 
	res += "world"l
	return res или return move(res)?
}
</code></pre>
<p>Здесь всё равно будет move, даже если вы ретурните локальную переменную. Надо писать просто <code>return res</code>. Написав <code>return move(res)</code>, вы подавите NRVO.</p>
<p>Если ваш класс не поддерживает rvalue-ссылки, что произойдёт, когда вы напишете <code>std::move(a)</code>? Просто вызовется конструктор копирования. Поэтому стоит рассматривать move как подсказку, что здесь можно мувать, а не обязательство. Так же нужно беспокоиться о том, бросаются ли исключения в строчке <code>move(a)</code>.</p>
<pre><code>T* new_data = operator new(sizeof(t) * new_capacity); 
for (size_t i = 0; i != size(); ++i) 
	new (&amp;new_data[i]) T(std::move(old_data[i])); 
</code></pre>
<p>Такое копирование не exception-safe, потому что T может не поддерживать move, и тогда вызовется обычный конструктор, поэтому так делать нельзя.<br>
Поэтому есть два варианта. Если исключения могут возникнуть, то принимается решение просто копировать. Если же не могут, то работает реализация выше.<br>
Как это проверить?<br>
<code>string (string &amp;&amp;) noexcept</code> – <code>noexcept</code> означает, что не будет бросаться исключение. Можно использовать и в выражениях: <code>enable_if&lt;noexcept(a + b)&gt;::type</code>. Если у вас есть move-конструктор, следует пометить его noexcept, если он является таковым. Можно внутри скобок после <code>noexcept</code> написать <em>любое</em> булевое выражение. Например, <code>noexcept(false)</code> означает, что бросает. Деструкторы по-умолчанию помечаются как noexcept, поэтому из деструктора нельзя бросить исключение, если не будет помечено <code>noexcept(false)</code>.  <mark>Goto tr_1</mark></p>
<h3 id="sfinae-ошибка">SFINAE-ошибка</h3>
<pre><code>template &lt;typename T&gt;
typename T::type f(T); 
void f(int); 
f(42); 
</code></pre>
<p>Внутри int нет type, это приведёт к ошибке (но не хардовой, просто перегрузка не будет рассматриваться).<br>
<strong>SFINAE</strong> – substitution failure is not an error</p>
<p><mark>tr_1</mark></p>
<h3 id="destructive-move">Destructive-move</h3>
<p>…</p>
<h2 id="perfect-forwarding">Perfect-forwarding</h2>
<p>Пусть у меня есть функция f:</p>
<pre><code>void f(int);
void f(char); 

template &lt;typename T&gt;
void g(T const &amp;a) {
	f(a); 
}

template &lt;typename T&gt; 
void g(T &amp;a) {
	f(a); 
}
</code></pre>
<p>Мы хотим как бы сохранить тип, который передали. Зачем это нужно? Например, если у меня есть <code>struct foo { foo(int, int, int) }</code>.<br>
<code>make_shared&lt;foo&gt;(1, 2, 3)</code> отфорвардит свои аргументы в конструктор foo.<br>
Такой тип форвардинга сохранят тип, но не сохраняет lvalue и rvalue. Независимо от пришедшего типа, <code>f</code> всегда получит lvalue.</p>
<pre><code>template &lt;typename T&gt; 
void f(T &amp;&amp;);

int a; 
int const b; 

f(a); // передаём lvalue. T -&gt; int&amp;
f(5); // передаём rvalue, T -&gt; int
f(b); // передаём lvalue, T -&gt; int const &amp;
</code></pre>
<p>Так определили новые правила в С++11.</p>
<p>Когда у нас были обычные ссылки, действовало следующее правило:</p>
<pre><code>typedef int&amp; foo; 
typedef foo&amp; bar; 
// ссылка на ссылку -- всё ещё ссылка (правило из С++03)
</code></pre>
<p>С появлением rvalue-ссылок, правило расширили:</p>
<pre><code>&amp;  &amp;  -&gt; &amp;
&amp;  &amp;&amp; -&gt; &amp;
&amp;&amp; &amp;  -&gt; &amp;
&amp;&amp; &amp;&amp; -&gt; &amp;&amp; 
</code></pre>
<p>Сохраняет тип, сохраяет константность, сохраним r/l-value.</p>
<pre><code>template&lt;typename T&gt; 
void f(T&amp;&amp; a) 
{
	g(static_cast&lt;T&amp;&amp;&gt;(a)); 
}
</code></pre>
<p>Обычно так static_cast не пишут, существует стандартная функция:</p>
<pre><code>template&lt;typename T&gt; 
T&amp;&amp; forward (T&amp; a) {
	return static_cast&lt;T&amp;&amp;&gt; (a); 
}

template&lt;typename T&gt; 
void f(T&amp;&amp; a) {
	g(forward&lt;T&gt; (a));
}
</code></pre>
<p>Есть один <em>тонкий</em> момент между move и forward.<br>
В наших записях они выглядят одинаково, в библиотеке написаны по разному. В move мы не передаём темплейтные параметры, в forward мы явно передаём темплейтный параметр.<br>
В библиотеке:</p>
<pre><code>template&lt;typename T&gt; 
T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp; a);  //g(move(a))??? 
</code></pre>
<p>Теперь T не может вывестись, мы обязаны его явно передать.</p>
<p>Что делать для n аргументов?</p>
<pre><code>template&lt;typename ... T&gt; // набор аргументов
void f(T&amp;&amp; ... a) {
	g(forward&lt;T&gt; (a) ...); 
}
</code></pre>
<p>Так, написан, например, <code>make_shared&lt;T&gt; (pointer)</code>.</p>
<h2 id="новая-пара-новая-жизнь">Новая пара, новая жизнь</h2>
<h3 id="auto">auto</h3>
<pre><code>std::vector&lt;std::string&gt; v; 
for (std::vector&lt;std::string&gt;::interator i = v.begin(); i != v.end(); ++i) {
	*i; 
}
// было -&gt; стало
for (auto i = v.begin(); i != v.end(); ++i) {
	*i;
}
</code></pre>
<p><code>auto a = f();</code> – вывод типа происходит так же, как происходит в выводе типов в шаблонах.<br>
<code>auto &amp;a = f();</code> – <code>template &lt;typename T&gt; void b(T&amp;);</code></p>
<p><strong>BP:</strong> если где-то можно написать auto, пожалуй, стоит так и делать. Однако, в некоторых случаях <em>явно</em> написанный тип будет удобнее (повышает читаемость).</p>
<p><code>typedef std::vector&lt;std::string&gt; strings</code> – ещё один способ заменить постоянное повторение в коде сложных типов.</p>
<h3 id="анонимные-функции">Анонимные функции</h3>
<p>Три способа передать компаратор в функцию <code>sort()</code>.</p>
<pre><code>template &lt;typename It, typename Comp&gt; 
void sort(It first, It last, Comp comp) {
	...
}

bool abs_less(int a, int b) {
	return abs(a) &lt; abs(b); 
}

struct abs_less1 {
	bool operator() (int a, int b) const {
		return abs(a) &lt; abs(b);
	}
};

vector&lt;int&gt; v; 
sort(v.begin(), v.end(), abs_less);
sort(v.begin(), v.end(), std::less);
sort(v.begin(), v.end(), abs_less1());
</code></pre>
<p>Так жить можно, но грустно. Если это какая-то часто используемая функция, ещё ОК, но если эта функция используется один раз – это вообще не круто.</p>
<p>Как это можно было бы написать в С++11:</p>
<pre><code>sort(v.begin(), v.end(), [](int a, int b) {
	return abs(a) &lt; abs(b); 
});
</code></pre>
<p>Что происходит внутри? Внутри компилятор заводит как будто бы локальную структуру. Он заводит в ней оператор круглые скобки и делает в ней то, что мы указали в теле функции.</p>
<p>Что можно написать в <code>[]</code>? В них указывается, что лямбда должна захватывать из контекста.</p>
<pre><code>
struct mod_less1 {
	mod_less(int n): n(n) {}
	bool operator() (int a, int b) const {
		return a % n &lt; b % n;
	}
	int n; 
};

sort(v.begin(), v.end(), [k](int a, int b) {
	return a % k &lt; b % k; 
}
int k;
</code></pre>
<p>В <code>[]</code> можно написать:</p>
<ul>
<li><code>[]</code> – ничего не нужно захватывать</li>
<li><code>[a, b, c]</code> – захватить локальные переменные</li>
<li><code>[&amp;a, &amp;b, &amp;c]</code> – захватить по ссылке</li>
<li><code>[=, &amp;a, &amp;b, &amp;c]</code> – а, b и c по ссылке, всё остальное по значению</li>
<li><code>[&amp;, a, b, c]</code> – наоборот</li>
</ul>
<p>Скобки у лямбы позволяют написать несколько дополнительных параметров :</p>
<ul>
<li><code>[]()</code> – ничего</li>
<li><code>[]() -&gt; bool</code> – явно указываем тип возвращаемого значения</li>
<li><code>[]() mutable -&gt; bool</code> – оператор <code>()</code> не const.</li>
</ul>
<p>Одну лямбду можно использовать в нескольких местах.<br>
<code>auto f = [](int a){};</code></p>
<p>Такое вот не скомпилируется:</p>
<pre><code>auto cmp; 
...
if(flag)
	cmp = [](int a, int b) { return a &lt; b };
else 
	cmp = [](int a, int b) { return b &lt; a }; 
</code></pre>
<p>А вот так уже будет работать:</p>
<pre><code>std::function&lt;bool(int, int)&gt; cmp; 
if(flag)
	cmp = [](int a, int b) { return a &lt; b };
else 
	cmp = [](int a, int b) { return b &lt; a }; 
</code></pre>
<p>Почему тогда лямбдам не назначили сразу тип std::function?</p>
<pre><code>bool f (int, int); 
bool y (int, int); 
bool h (int, int); 
//Динамический полиморфизм
sort(..., ..., &amp;f); //одна и та же сортировка
sort(..., ..., &amp;y); //просто "прыгаем" на компаратор
sort(..., ..., &amp;h); 
//Статический полиморфизм
sort(..., ..., F()); //три разные сортировки
sort(..., ..., Y());
sort(..., ..., H());
</code></pre>
<p>Отличие по времени работы в разы.</p>
<p>Оптимизация</p>
<pre><code>for( ; ;) {
	if (cmp == &amp;f) 
		f(a, b); 
	else if (cmp == &amp;g)
		g(a, b); 
	else 
		cmp(a, b); 
}
</code></pre>
<p>Может быть преобразовано в:</p>
<pre><code>if (cmp == &amp;f) 
	for ( ; ; ) 
		f(); 
else if (cmp == &amp;y) 
	... 
</code></pre>
<p>Ответим, почему не <code>std::function</code>. Он в какой-то степени предполагает динамический полиморфизм. А лямбды позволяют сортам работать со статическим и работать быстрее.</p>
<p>Если лямбда ничего не захватывает, она может быть приведена к указателю на функцию.</p>
<h2 id="stdfunction">std::function</h2>
<h3 id="type-erasure">type erasure</h3>
<pre><code>//std::function&lt;bool(int, int)&gt; cmp = [](){};

struct function {
	template &lt;typename F&gt;
	function (F f) :
		ptr (std::make_unique&lt;model&lt;F&gt;&gt;(std::move(f))){}
	function (function const &amp;other) :
		ptr (other.ptr-&gt;copy());
	bool operator() (int a, int b) const {
		return ptr-&gt;call(a, b); 
	}
	
	private: 
		std::unique_ptr&lt;concept&gt; ptr;
};

struct function::concept {
	virtual ~concept();
	virtual unique_ptr&lt;concept&gt; copy() const; 
	virtual bool call(int a, int b); 
};

template &lt;typename F&gt; 
struct function::model : concept {
	model (F f): f(std::move(f)) {}
	unique_ptr&lt;concept&gt; copy() { return make_unique&lt;model&lt;F&gt;&gt;(f); }
	bool call(int a, int b) { return f(a, b); } 
	
	F f;
}
</code></pre>
<p>Примеры применения данной техники:</p>
<ul>
<li><code>any_iterator&lt;int&gt;</code></li>
<li><code>any_range&lt;int&gt;</code></li>
<li><code>any</code></li>
</ul>
<h3 id="разные-вещи">Разные вещи</h3>
<pre><code>template &lt;typename T, typename ... A&gt; 
unique_ptr&lt;T&gt; make_unique(A &amp;&amp; ... a) {
	return unique_ptr&lt;T&gt;(new T(forward&lt;A&gt;(a) ... )); 
}

//f(g(a...)) -&gt; f(g(a0, a1, a2, ...))
//f(g(a)...) -&gt; f(g(a0), g(a1), ...)
</code></pre>
<p>Несколько <code>...</code> должны иметь одинаковую длину, если мы хотим, чтобы они экспандились вместе.</p>
<p>Специально для таких темплейтов существует <code>sizeof...</code> Позволяет узнать, сколько у темплейта параметров.</p>
<p>Как могло бы выглядеть итерирование по шаблонам с переменным числом аргументов:</p>
<pre><code>at&lt;5, Ts ...&gt;::type 

template&lt;size_t N, typename T0, typename ... Ts&gt;
struct at {
	typedef typename ar&lt;N-1, Ts ...&gt;::type type;
};

template &lt;typename T0, typename ... Ts&gt; 
struct ar&lt;0, T0, Ts ... &gt; {
	typedef T0 type;
}
</code></pre>
<h2 id="signals">Signals</h2>
<p>Signals aka (listeners, observer) не то же самое, что UNIX-signals.</p>
<pre><code>struct signal { 
	struct connetion; 
	
	typedef function&lt;void()&gt; slot; 
		
	connetion connect(slot s) {
		slots.push_back(move(s)); 
	}
	
	void operator()() const {
		for (auto&amp;&amp;&amp; s: slots) 
			try { 
				s(); 
			} catch (...) {
				log("..."); 
			}
	}
	
private:
	list&lt;slot&gt; slots;
}

struct signal::connection {
	connection(signal *sig, list&lt;slot&gt;::interator it)
								: sig(sig), it(it) {}
	void disconnect() {
		sig-&gt;slots.erase(it);
	}
private:
	signal* sig; 
	list&lt;slot&gt;::iterator it; 
}
</code></pre>
<p>Здесь есть <em>критическая</em> ошибка.  “Не могу поинкрементить, неправильный итератор”. Мы удалили объект из листа во время прохода по нему, если мы дисконнектнулись внутри <code>s</code></p>
<pre><code>void operator()() const {
	for (auto i = slots.begin(); i != slots.end(); ++i) 
		(*i)(); 
</code></pre>
<p>Как это пофиксить? Такая реализация уже имеет место быть, она даже популярна.</p>
<pre><code>void operator()() const {
	vector&lt;slot&gt; copy = slots;
	for (auto i = copy.begin(); i != copy.end(); ++i) 
		(*i)(); 
</code></pre>
<p>Это чинит нашу проблему, сигнал теперь сам не ломается, но теперь у него есть очень странное свойство: когда сигнал <code>A</code> отписывает себя и сигнал <code>B</code>, сигнал <code>B</code> всё равно будет вызван. В этой реализации нет команды “Отписаться”. Можно реализовать лишь “Отпишись через <em>какое-нибудь</em> время”.</p>
<p>Используем bool:</p>
<pre><code>struct signal { 
	struct connetion; 
	
	typedef function&lt;void()&gt; slot; 
		
	connetion connect(slot s) {
		slots.push_back(move(s)); 
	}
	
	void operator()() const {
		for(auto&amp;&amp; s: slots) {
			if (s.first) 
				s.second();
		slots.erase(remove_if(slots.begin(), slots.end(), [](pair&lt;bool, slot&gt; const&amp; p) {return !p.first;}), slot.end());
	}
	
private:
	list&lt;pair&lt;bool, slot&gt;&gt; slots;
}
</code></pre>
<p>Выглядит, как будто этот код будет работать всегда, однако это не так.<br>
Call_stack:</p>
<pre><code>signal::op()
|	A
|	|	signal::op()
|	|	|	B
|	|	|	|	disconnect
|	|	|	cleanup	
++i 
//В этом месте мы пытаемся разыменовать итератор,
//который был удалён в cleanup
</code></pre>
<p>Попробуем пофиксить:</p>
<pre><code>struct signal { 
	struct connetion; 
	
	typedef function&lt;void()&gt; slot; 
		
	connetion connect(slot s) {
		slots.push_back(move(s)); 
	}
	
	void operator()() const {
		++rec_counter; 
		for (auto &amp;&amp;p: slots) 
			if(p.first) 
				p.second(); 
		--rec_counter; 
		if (rec_counter == 0)
			for (auto i = slots.begin(). i != slots.end(); ) 
				if(i-&gt;first)
					++i;
				else 
					i = slots.erase(i);
	}
	
private:
	size_t  rec_counter; 
	list&lt;pair&lt;bool, slot&gt;&gt; slots;
}


struct signal::connection {
	connection(signal *sig, list&lt;slot&gt;::interator it)
								: sig(sig), it(it) {}
	void disconnect() {
		if (sig-&gt;rec_counter == 0)
			sig.slots.erase(it);
		else 
			if-&gt;first = false;
	}
private:
	signal* sig; 
	list&lt;slot&gt;::iterator it; 
}

</code></pre>
<h3 id="reentrancy---связанная-с-этим-проблема">Reentrancy - связанная с этим проблема</h3>
<h2 id="bind-и-variadic-templates">Bind и variadic-templates</h2>
<pre><code>void f(int, int, int) ; 
void g(int, int);
bind(f, 1, 2, 3)(); //f(1, 2, 3)
bind(f, 4, _1, 5)(6); //f(4, 6, 5) _1 == первый элемент, который передали в скобках
bind(f, _3, _2, _1)(7, 8, 9) //f(9, 8, 7)
bind(f, _2, _2, _3)(10, 11, 12) //f(11, 11, 12)
bind(f, _1, bind(g, _2, 42), 43)(44, 45) //f(44, g(45, 42), 43)
</code></pre>
<p><code>_1</code> называется <code>std::placeholders&lt;N&gt;</code></p>
<p><code>bind(r, 1, 2, _1) (3)</code> // 1, 2, _1, = b<sub>i</sub>, 3 = a<sub>i</sub></p>
<pre><code>template&lt;typename F, typename ... Bs&gt;
bind_t &lt;F, Bs ...&gt; bind(F f, Bs ... bs) {
	return bind_t&lt;F, Br ...&gt;(move(f), move(bs)...);
	}	
}

template &lt;typename F, typename ... Bs&gt; 
struct bind_t {
	bind_t(F f, Bs bs) : f(move(f)), gs(move(bs)...); 
	tuple&lt;G&lt;Bs&gt;...&gt; gs; //куда-то сюда вставить F f
}

template &lt;typename T&gt;
struct G {
	G(T value) : value(move(value)) {}
	template&lt;typename ... As&gt;
	T operator()(As const&amp; ... as) {
		return value;
	}
};

template &lt;size_t N&gt;
struct G&lt;placeholders&lt;N&gt;&gt; {
	template &lt;typename A, typename ... As&gt; 
		auto operator()(A const&amp; a0, As const&amp; ... as) {
			return G&lt;N-1&gt;()(as);
		}
}

template &lt;&gt;
struct G&lt;placeholders&lt;0&gt;&gt; {
	template&lt;typename A, typename ... As&gt;
	A operator(A const&amp; a, As const&amp; ... as) {
		return a; 
	}
}

teamplate &lt;typename ... As, size_t Indices&gt;
auto call(index_tuple&lt;Indices...&gt;, As const&amp; ... as) {
	return f(get&lt;Indices&gt;(gs)(as ...)...); 
}

template &lt;typename ... As&gt;
auto operator()(As const&amp; as) const {
	return call(make_index_tuple&lt;sizeof ...(Bs)&gt;(), as ...); 
}

template &lt;size_t N, size_t ... Indices&gt;
struct make_index_tuple {
	typedef make_index_tuple&lt;N - 1, N - 1, Indices ...&gt;::type type;
};

template&lt;size_t ... Indices&gt; 
struct make_index_tuple &lt;0&gt;{
	typedef index_tuple&lt;Indices ...&gt; type; 
};
</code></pre>

    </div>
  </div>
</body>

</html>
